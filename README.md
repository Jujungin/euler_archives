# euler_archives
---
## Q001. Multiples of 3 or 5
> Q. If we list all the natural numbers below  10 that are multiples of 3 or 5, we get 3,5,6 and 9. The sum of these multiples is 23.Find the sum of all the multiples of 3 or 5 below 1000.
1. 간단하게 조건문으로 해결
```python
for 범위
    if 3, 5의 배수
```
2. 수학적 계산
등차수열의 합을 구하는 문제로 3의 배수와 5의 배수를 각각 따로 계산한 뒤, 중복되는 부분을 제거
```python
sum_3의 배수
+ sum_5의 배수
- sum_3*5의 배수
```
3. 비교
   
    ![Q001](https://github.com/Jujungin/euler_archives/assets/37700849/d63fc1b2-aabf-44b3-b5ce-63e1ac92640a)

X: 10, 100, 1000, 10000, 100000, 1000000

Y: 시간(초)

Function 01: O(N)

Function 02: O(1)

---

## Q002. Even Fibonacci Numbers
> Q. Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:   1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ... By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.

1. list를 사용하여 계산

    list를 사용하여 fibonacci를 저장하면, 계산한 값을 메모리에 저장하기 때문에 list의 크기가 증가하면서 메모리 사용량도 증가한다. 또한 list에 저장되는 값이 적더라도 list에 포함된 값에 접근하는 것도 메모리 엑세스가 필요하기에 시간 비용이 커질수 있다.

2. list 없이 계산

    1 에서는 list로 cost가 증가했지만 단순한 변수 저장으로 메모리 공간과 시간을 눈에띄게 줄일수 있다.

3. recursive function

    재귀함수의 경우는 tree 구조로 fibonacci의 경우 호출시 두 개의 하위를 생성하며 동작하기 때문에 2^n 으로 크다.

4. 비교 (매 trial 마다 그래프가 달라, 평균값 사용)

    ![Q002_01_02](https://github.com/Jujungin/euler_archives/assets/37700849/2c390eff-396c-41ef-bb06-ab37260e971b)

X: 10, 100, 1000, 10000, 100000, 1000000, 4000000

Y: 시간(초)

Function 01: 구조상 O(N)

Function 02: 구조상 O(N)

   ![Q002_01_02_03](https://github.com/Jujungin/euler_archives/assets/37700849/827617bc-65c9-4dd5-8fc0-8124c9802528)


X: 10, 100, 1000, 10000, 100000, 1000000, 4000000

Y: 시간(초)

Function 01: 구조상 O(N)

Function 02: 구조상 O(N)

Function 03: 구조상 O(2^N)

---

## Q003. Largest Prime Factor
> Q. The prime factors of 13195 are 5, 7, 13 and 29.
What is the largest prime factor of the number 600851475143 ?

1. 정리

   Eratosthenes' Sieve
   가장 작은 소수인 2부터 시작하여 해당 소수의 배수를 모두 제거하고, 남아 있는 가장 작은 수를 새로운 소수로 선택, 해당 소수의 모든 배수를 제거, 이 과정을 반복한다.

2. 시간복잡도

   ![Q003](https://github.com/Jujungin/euler_archives/assets/37700849/fb0ce14d-3ea5-474d-90ad-6e5d82f11c7b)

---

## Q004. Largest Palindrome Product
> Q. A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 * 99. Find the largest palindrome made from the product of two 3-digit numbers.

1. 정리

   가장 중요한 핵심은 str로 변환후 뒤집었을때 palindrome인지 아닌지 확인하는게 핵심.

   ```python
   if str(product) == str(product)[::-1]:
   ```

---

## Q005. Smallest Multiple
> Q. 2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder. What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?

1. 정리

   범위의 모든 수를 소인수분해하여, 각 소수의 최대 지수를 찾고, 최소공배수를 계산하는 방법을 사용.

   ```python
   20 = 2^2 * 5^1
   ```

2. sudo
   ```python
   1. 소인수분해 함수를 만든다.

        함수 prime_factors(n)을 정의한다.
        n을 인자로 받는다.
        factors라는 빈 딕셔너리를 생성한다.
    
        while n이 1보다 큰 동안 반복한다:
            for divisor in range(2, n+1)로 반복한다:
                count를 0으로 초기화한다.
                while n이 divisor로 나누어질 때까지 반복한다:
                    count를 1 증가시킨다.
                    n을 divisor로 나눈다.
                if count가 0보다 크면:
                    factors 딕셔너리에 divisor를 키로 하고 count를 값으로 저장한다.
    
        factors를 반환한다.

    2. 가장 작은 양수를 찾는 함수를 만든다.
    
        함수 smallest_multiple(n)을 정의한다.
        n을 인자로 받는다.
        prime_factors_count라는 빈 딕셔너리를 생성한다.
    
        for i in range(2, n+1)로 반복한다:
            factors를 prime_factors(i)로 설정한다.
            for factor, count in factors.items()로 반복한다:
                if factor가 prime_factors_count에 없거나, count가 prime_factors_count[factor]보다 크면:
                    prime_factors_count[factor]를 count로 업데이트한다.
    
        result를 1로 초기화한다.
        for factor, count in prime_factors_count.items()로 반복한다:
            result에 factor의 count 제곱을 곱한다.
    
        result를 반환한다.

    3. 문제를 해결한다.
    
        result를 smallest_multiple(20)으로 설정한다.
        result를 출력한다.

   ```


---

## Q006. Sum Square Difference
The sum of the squares of the first ten natural numbers is, <br/>

```math
1^2 + 2^2 + ... + 10^2 = 385
```


The square of the sum of the first ten natural numbers is, <br/>

```math
(1 + 2 + ... + 10)^2 = 55^2 = 3025
```

Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is <br/>

```math
3025 - 385 = 2640
```

Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.

<br>

1. 정리

    수학적 접근


    **합의 제곱**
    ```math
    \text{{square\ of\ sum}} = (1 + 2 + \ldots + n)^2 = \left(\frac{{n \cdot (n + 1)}}{2}\right)^2
    ```
    

    **제곱의 합**
    ```math
    \text{sum\ of\ square} = 1^2 + 2^2 + \ldots + n^2 = \frac{{n \cdot (n + 1) \cdot (2n + 1)}}{6}
    ```


3. 비교
   
   ![Q006](https://github.com/Jujungin/euler_archives/assets/37700849/14a927ea-1112-4df5-a4a8-2b81e1671c76)
